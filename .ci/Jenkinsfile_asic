@Library("jenlib") _

/**
 * Temporary files for the build, to be deleted at the end of every job.
 * We replace '/tmp' because it might not feature enough space for large builds
 * by some network-mounted large storage.
 */
env.TMPDIR = "/wang/environment/software/Carbon/spack/tmp/" + UUID.randomUUID().toString()

/**
 * Build was triggered by some gerrit event
 */
GERRIT_BUILD = (boolean) env.GERRIT_CHANGE_NUMBER

/**
 * Build was triggered by a "merged" event from gerrit
 */
MERGE_BUILD = (env.GERRIT_EVENT_TYPE == "change-merged")


try {
	runOnSlave(name: "uranus") {
		withEnv(['ftp_proxy=ftp://proxy.kip.uni-heidelberg.de:2121',
		         'http_proxy=http://proxy.kip.uni-heidelberg.de:8080',
		         'https_proxy=http://proxy.kip.uni-heidelberg.de:8080',
		         'no_proxy=localhost,kip,kip.uni-heidelberg.de,129.206.179.*,129.20'
		]
		) {
			if (GERRIT_BUILD) {
				LIVE_INSTANCE = "/wang/environment/software/Carbon/spack/${env.GERRIT_BRANCH}_live"
				STAGE_INSTANCE = "/wang/environment/software/Carbon/spack/${env.GERRIT_BRANCH}_staging"
			}

			// Branch is not available when not triggered via gerrit
			// TODO: Fix this when moving to a different branch!
			NIGHTLY_INSTANCE = "/wang/environment/software/Carbon/spack/visionary_nightly"

			if (MERGE_BUILD) {
				// Clean up stages of this changeset
				sh "rm -rf ${STAGE_INSTANCE}/c${env.GERRIT_CHANGE_NUMBER}p*"

				WORKING_DIR = LIVE_INSTANCE
			} else if (GERRIT_BUILD) {
				// Has to live on the same device as LIVE_INSTANCE for hardlinking spack views
				WORKING_DIR = "${STAGE_INSTANCE}/c${env.GERRIT_CHANGE_NUMBER}p${env.GERRIT_PATCHSET_NUMBER}"
			} else {
				WORKING_DIR = NIGHTLY_INSTANCE
				sh "cd ${WORKING_DIR} && find -delete"
			}

			dir(WORKING_DIR) {
				checkout scm

				ASIC_COMPILERS = readYaml(file: "etc/spack/compilers.yaml")["compilers"].collect{it["compiler"]["spec"]}
				echo "Found ASIC compiler specs: $ASIC_COMPILERS"
			}

			stage('setup') {
				sh("mkdir -p $TMPDIR")
			}

			stage('chain') {
				if (!MERGE_BUILD && GERRIT_BUILD) {
					sh "cd ${WORKING_DIR} && " +
					   // we need two -f to also be able to deal with .git files that can
					   // be added by sources of packages
					   "git clean -dfxf && " +
                       "export SPACK_ROOT=${WORKING_DIR} && " +
					   ". share/spack/setup-env.sh && " +
					   "(echo 'upstreams:' && " +
					   "echo '  live-instance:' && " +
					   "echo '    install_tree: ${LIVE_INSTANCE}/opt/spack') " +
					   "> etc/spack/upstreams.yaml"
				} else {
					echo "Omitting chaining for nightly build."
				}
			}

			stage('asic') {
				for(compiler in ASIC_COMPILERS){
					sh "env && " +
					   "cd ${WORKING_DIR} && " +
                       "export SPACK_ROOT=${WORKING_DIR} && " +
					   "set +x && " +
					   ". share/spack/setup-env.sh &&" +
					   "set -x && " +
					   "spack mirror add --scope site manual /wang/environment/software/Carbon/spack/download_cache && " +
					   "bash -ex .ci/02_install.sh asic_" + compiler + " \'visionary-asic\' \'" + compiler + "\' \'local\' && " +
					   "ln -sf ${WORKING_DIR}/modules/asic_" + compiler + "_${BUILD_ID} ${WORKING_DIR}/modules/asic_" + compiler
				}
			}
		}
	}
} catch (Throwable t) {
	notifyFailure(mattermostChannel: "#spack")
	throw t
} finally {
	runOnSlave(name: "uranus") {
		stage('Cleanup') {
			// Remove temporary files
			sh "rm -rf ${env.TMPDIR}"
		}
	}
}

if (currentBuild.currentResult != "SUCCESS") {
	notifyFailure(mattermostChannel: "#spack")
}
